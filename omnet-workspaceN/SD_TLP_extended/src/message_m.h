//
// Generated file, do not edit! Created by opp_msgtool 6.3 from message.msg.
//

#ifndef __MESSAGE_M_H
#define __MESSAGE_M_H

#if defined(__clang__)
#  pragma clang diagnostic ignored "-Wreserved-id-macro"
#endif
#include <omnetpp.h>

// opp_msgtool version check
#define MSGC_VERSION 0x0603
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgtool: 'make clean' should help.
#endif

class EvUpdate;
class TlCommand;
class QueueReport;
class SignalState;
class EvAtStopLine;
class EvGo;
class EvCleared;
class EvQueueAhead;
/**
 * Class generated from <tt>message.msg:1</tt> by opp_msgtool.
 * <pre>
 * message EvUpdate
 * {
 *     int evId; //ID of the EV
 *     int severity; // meaning priority: Ambulance=1, Fire=2, Police=3.
 *     int targetInter; // Which intersection the EV is currently approaching to know which traffic light is relevant
 *     int approach; //Which direction the EV is entering from --> 0=N, 1=E, 2=S, 3=W
 *     double DEMV; //distance (meters) from EV to the traffic light stop line
 *     double speed;
 *     simtime_t tSent;//Simulation time when the update was sent --> the time when the message is sent to the RSU
 *     double distToAP; // distance (meters) from EV to Accident Position (AP)
 * 
 * }
 * </pre>
 */
class EvUpdate : public ::omnetpp::cMessage
{
  protected:
    int evId = 0;
    int severity = 0;
    int targetInter = 0;
    int approach = 0;
    double DEMV = 0;
    double speed = 0;
    omnetpp::simtime_t tSent = SIMTIME_ZERO;
    double distToAP = 0;

  private:
    void copy(const EvUpdate& other);

  protected:
    bool operator==(const EvUpdate&) = delete;

  public:
    EvUpdate(const char *name=nullptr, short kind=0);
    EvUpdate(const EvUpdate& other);
    virtual ~EvUpdate();
    EvUpdate& operator=(const EvUpdate& other);
    virtual EvUpdate *dup() const override {return new EvUpdate(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getEvId() const;
    virtual void setEvId(int evId);

    virtual int getSeverity() const;
    virtual void setSeverity(int severity);

    virtual int getTargetInter() const;
    virtual void setTargetInter(int targetInter);

    virtual int getApproach() const;
    virtual void setApproach(int approach);

    virtual double getDEMV() const;
    virtual void setDEMV(double DEMV);

    virtual double getSpeed() const;
    virtual void setSpeed(double speed);

    virtual omnetpp::simtime_t getTSent() const;
    virtual void setTSent(omnetpp::simtime_t tSent);

    virtual double getDistToAP() const;
    virtual void setDistToAP(double distToAP);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EvUpdate& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EvUpdate& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:13</tt> by opp_msgtool.
 * <pre>
 * message TlCommand
 * {
 *     int intersectionId;//Identifies which intersection to control
 *     int approach;//Specifies which incoming direction at that intersection-->Only one approach is green at a time (so it can be green) 
 *     string action;//tells the traffic light what kind of preemption action to perform.
 *     double duration;//How long the action should last
 * }
 * </pre>
 */
class TlCommand : public ::omnetpp::cMessage
{
  protected:
    int intersectionId = 0;
    int approach = 0;
    omnetpp::opp_string action;
    double duration = 0;

  private:
    void copy(const TlCommand& other);

  protected:
    bool operator==(const TlCommand&) = delete;

  public:
    TlCommand(const char *name=nullptr, short kind=0);
    TlCommand(const TlCommand& other);
    virtual ~TlCommand();
    TlCommand& operator=(const TlCommand& other);
    virtual TlCommand *dup() const override {return new TlCommand(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);

    virtual int getApproach() const;
    virtual void setApproach(int approach);

    virtual const char * getAction() const;
    virtual void setAction(const char * action);

    virtual double getDuration() const;
    virtual void setDuration(double duration);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const TlCommand& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, TlCommand& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:20</tt> by opp_msgtool.
 * <pre>
 * message QueueReport
 * {
 *     int intersectionId;//Which intersection is reporting
 *     int approach;//Which approach (N/E/S/W) this report refers to
 *     int C;//the number of vehicles in front of the emergency vehicle at the intersection (queue length for an approach)
 *     double TD;//Traffic Density value to compare with the threshold
 * }
 * </pre>
 */
class QueueReport : public ::omnetpp::cMessage
{
  protected:
    int intersectionId = 0;
    int approach = 0;
    int C = 0;
    double TD = 0;

  private:
    void copy(const QueueReport& other);

  protected:
    bool operator==(const QueueReport&) = delete;

  public:
    QueueReport(const char *name=nullptr, short kind=0);
    QueueReport(const QueueReport& other);
    virtual ~QueueReport();
    QueueReport& operator=(const QueueReport& other);
    virtual QueueReport *dup() const override {return new QueueReport(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);

    virtual int getApproach() const;
    virtual void setApproach(int approach);

    virtual int getC() const;
    virtual void setC(int C);

    virtual double getTD() const;
    virtual void setTD(double TD);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const QueueReport& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, QueueReport& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:27</tt> by opp_msgtool.
 * <pre>
 * message SignalState //from intersection to ev that send the traffic signal state every second to ev.
 * {
 *     int intersectionId;
 *     int greenApproach;   // 0..3, or -1 for all-red
 *     bool preemptActive;
 * }
 * </pre>
 */
class SignalState : public ::omnetpp::cMessage
{
  protected:
    int intersectionId = 0;
    int greenApproach = 0;
    bool preemptActive = false;

  private:
    void copy(const SignalState& other);

  protected:
    bool operator==(const SignalState&) = delete;

  public:
    SignalState(const char *name=nullptr, short kind=0);
    SignalState(const SignalState& other);
    virtual ~SignalState();
    SignalState& operator=(const SignalState& other);
    virtual SignalState *dup() const override {return new SignalState(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);

    virtual int getGreenApproach() const;
    virtual void setGreenApproach(int greenApproach);

    virtual bool getPreemptActive() const;
    virtual void setPreemptActive(bool preemptActive);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const SignalState& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, SignalState& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:32</tt> by opp_msgtool.
 * <pre>
 * packet EvAtStopLine
 * {
 *     int evId;
 *     int intersectionId;
 *     int approach;
 *     int severity;
 * }
 * </pre>
 */
class EvAtStopLine : public ::omnetpp::cPacket
{
  protected:
    int evId = 0;
    int intersectionId = 0;
    int approach = 0;
    int severity = 0;

  private:
    void copy(const EvAtStopLine& other);

  protected:
    bool operator==(const EvAtStopLine&) = delete;

  public:
    EvAtStopLine(const char *name=nullptr, short kind=0);
    EvAtStopLine(const EvAtStopLine& other);
    virtual ~EvAtStopLine();
    EvAtStopLine& operator=(const EvAtStopLine& other);
    virtual EvAtStopLine *dup() const override {return new EvAtStopLine(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getEvId() const;
    virtual void setEvId(int evId);

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);

    virtual int getApproach() const;
    virtual void setApproach(int approach);

    virtual int getSeverity() const;
    virtual void setSeverity(int severity);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EvAtStopLine& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EvAtStopLine& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:39</tt> by opp_msgtool.
 * <pre>
 * packet EvGo
 * {
 *     int evId;
 *     int intersectionId;
 * }
 * </pre>
 */
class EvGo : public ::omnetpp::cPacket
{
  protected:
    int evId = 0;
    int intersectionId = 0;

  private:
    void copy(const EvGo& other);

  protected:
    bool operator==(const EvGo&) = delete;

  public:
    EvGo(const char *name=nullptr, short kind=0);
    EvGo(const EvGo& other);
    virtual ~EvGo();
    EvGo& operator=(const EvGo& other);
    virtual EvGo *dup() const override {return new EvGo(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getEvId() const;
    virtual void setEvId(int evId);

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EvGo& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EvGo& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:44</tt> by opp_msgtool.
 * <pre>
 * message EvCleared
 * {
 *     int evId;
 *     int intersectionId;
 * }
 * </pre>
 */
class EvCleared : public ::omnetpp::cMessage
{
  protected:
    int evId = 0;
    int intersectionId = 0;

  private:
    void copy(const EvCleared& other);

  protected:
    bool operator==(const EvCleared&) = delete;

  public:
    EvCleared(const char *name=nullptr, short kind=0);
    EvCleared(const EvCleared& other);
    virtual ~EvCleared();
    EvCleared& operator=(const EvCleared& other);
    virtual EvCleared *dup() const override {return new EvCleared(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getEvId() const;
    virtual void setEvId(int evId);

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EvCleared& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EvCleared& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>message.msg:48</tt> by opp_msgtool.
 * <pre>
 * packet EvQueueAhead
 * {
 *     int evId;
 *     int intersectionId;
 *     int approach;
 *     int ahead;   // cars still ahead of EV
 * }
 * </pre>
 */
class EvQueueAhead : public ::omnetpp::cPacket
{
  protected:
    int evId = 0;
    int intersectionId = 0;
    int approach = 0;
    int ahead = 0;

  private:
    void copy(const EvQueueAhead& other);

  protected:
    bool operator==(const EvQueueAhead&) = delete;

  public:
    EvQueueAhead(const char *name=nullptr, short kind=0);
    EvQueueAhead(const EvQueueAhead& other);
    virtual ~EvQueueAhead();
    EvQueueAhead& operator=(const EvQueueAhead& other);
    virtual EvQueueAhead *dup() const override {return new EvQueueAhead(*this);}
    virtual void parsimPack(omnetpp::cCommBuffer *b) const override;
    virtual void parsimUnpack(omnetpp::cCommBuffer *b) override;

    virtual int getEvId() const;
    virtual void setEvId(int evId);

    virtual int getIntersectionId() const;
    virtual void setIntersectionId(int intersectionId);

    virtual int getApproach() const;
    virtual void setApproach(int approach);

    virtual int getAhead() const;
    virtual void setAhead(int ahead);
};

inline void doParsimPacking(omnetpp::cCommBuffer *b, const EvQueueAhead& obj) {obj.parsimPack(b);}
inline void doParsimUnpacking(omnetpp::cCommBuffer *b, EvQueueAhead& obj) {obj.parsimUnpack(b);}


namespace omnetpp {

template<> inline EvUpdate *fromAnyPtr(any_ptr ptr) { return check_and_cast<EvUpdate*>(ptr.get<cObject>()); }
template<> inline TlCommand *fromAnyPtr(any_ptr ptr) { return check_and_cast<TlCommand*>(ptr.get<cObject>()); }
template<> inline QueueReport *fromAnyPtr(any_ptr ptr) { return check_and_cast<QueueReport*>(ptr.get<cObject>()); }
template<> inline SignalState *fromAnyPtr(any_ptr ptr) { return check_and_cast<SignalState*>(ptr.get<cObject>()); }
template<> inline EvAtStopLine *fromAnyPtr(any_ptr ptr) { return check_and_cast<EvAtStopLine*>(ptr.get<cObject>()); }
template<> inline EvGo *fromAnyPtr(any_ptr ptr) { return check_and_cast<EvGo*>(ptr.get<cObject>()); }
template<> inline EvCleared *fromAnyPtr(any_ptr ptr) { return check_and_cast<EvCleared*>(ptr.get<cObject>()); }
template<> inline EvQueueAhead *fromAnyPtr(any_ptr ptr) { return check_and_cast<EvQueueAhead*>(ptr.get<cObject>()); }

}  // namespace omnetpp

#endif // ifndef __MESSAGE_M_H

